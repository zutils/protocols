syntax = "proto3";

// This Schema represents how data will be sent to and from all foreign interfaces.
//  It will allow personal modules to be sent to dynamic libraries, webasm, and locally
//  Please NOTE: This is an INSECURE method of transport. All destinations for these messages should be FULLY TRUSTED!

message SchemaIdentifier {
    string id = 1;
}

message PeerIdentifier {
    string id = 1;
}

message Sender {
    string ipns_layer = 1;
    PeerIdentifier ipns_sender = 2;
}

message Error { string error = 1; }

// Include data and the schema that can deserialize it.
message Data {
    SchemaIdentifier schema = 1;
    bytes serialized_data = 2;
    Sender sender = 3;
}

// Include the method name and the serialized RPC data.
message RpcData {
    // name, data, and deserializer are the three things we need as a destination for RpcData
    string method_name = 1;
    bytes serialized_rpc_arg = 2;
    SchemaIdentifier schema = 3;

    // The RpcData may hold all children and where to send that data. 
    // If we return to the caller function, we need to identify it.
    RpcData next_path = 4;
    Sender sender = 5;
}

message ModuleInfo {
    SchemaIdentifier schema = 1;
    string name = 2;
}

// Special case for functions that would normally take Destination
message Destination {
    SchemaIdentifier schema = 1;
}

message VecData { repeated Data vec = 1; }
message VecModuleInfo { repeated ModuleInfo vec = 1; }
message VecRpcData { repeated RpcData vec = 1; }

enum RequestType {
    NONE = 0;
    GET_INFO = 1;
    RECEIVE_RPC_AS_CLIENT = 2;
    RECEIVE_RPC_AS_SERVER = 3;
    RECEIVE_PUBLIC_RPC = 4;
}


// Because we don't support generics - have a oneof for each result. The calling function should know which one it is expecting.
message DataType {
    oneof result {
        Error error = 1;
        Data data = 2;
        VecModuleInfo vecmoduleinfo = 3;
        RpcData rpcdata = 4;
        Destination destination = 5;
        VecData vecdata= 6;
        VecRpcData vecrpcdata = 7;
    }
}

// Any module that wants to communicate to another module in it's tree must send and receive "Transports"
message Transport {
    SchemaIdentifier destination = 1;
    DataType payload = 2;
    RequestType request_type = 3;
}

message VecTransport { repeated Transport vec = 1; }

service CommonModule {
    rpc get_info(Destination) returns (VecModuleInfo);
    rpc receive_rpc_as_client(RpcData) returns (VecRpcData);
    rpc receive_rpc_as_server(RpcData) returns (VecRpcData);
    rpc receive_public_rpc(RpcData) returns (VecRpcData);
}
