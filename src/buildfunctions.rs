//! buildfunctions provides functions to be used in plugins' build.rs file.
use protobuf_codegen_pure as pcp;
use protoc_rust_grpc as prg;
use failure::{Error, format_err};
use std::fs::File;	
use std::path::PathBuf;

/// Call protoc on protobuffer and create non-rpc code
pub fn build_rust_code_from_protobuffer(proto_filename: &PathBuf) -> Result<(), Error> {
	println!("Building protobuf for {:?}", &proto_filename);

	let path_str = proto_filename.to_str().ok_or(format_err!("Cannot create str from PathBuf!"))?;

	let mut customize = pcp::Customize::default();
	customize.serde_derive = Some(true);

	let args = pcp::Args {
			out_dir: "src",
			input: &[path_str],
			includes: &["./schema"],
			customize
	};

	pcp::run(args).expect("protoc");

	println!("Protoc ran on {}", path_str);
	Ok(())
}

/// Call protoc on protobuffer and create only the rpc code
pub fn build_rust_rpc_code_from_protobuffer(proto_filename: &PathBuf) -> Result<(), Error> {
	println!("Building protobuf rpc for {:?}", &proto_filename);
	let path_str = proto_filename.to_str().ok_or(format_err!("Cannot create str from PathBuf!"))?;

	let args = prg::Args {
			out_dir: "src",
			input: &[path_str],
			includes: &["./schema"],
			rust_protobuf: false,
			..Default::default()
	};

	prg::run(args).expect("protoc-rust-grpc");

	println!("Protoc-rust-grpc ran on {}", path_str);

	Ok(())
}

/*pub fn modify_rust_rpc_code_to_use_custom_structs(path: &PathBuf) -> Result<(), Error> {
	// Retrieve rpc autogenerated code path
	let base_name: String = path.file_stem().unwrap().to_str().unwrap().to_string();
	let grandparent_path = path.parent().unwrap().parent().unwrap();
	let mut grpc_path = grandparent_path.to_path_buf();
	grpc_path.push("src");
	grpc_path.push(base_name + "_grpc.rs");

	if !grpc_path.exists() {
		return Ok(());
	}

	println!("Modifying {:?}", grpc_path);
	let original_data = ::std::fs::read_to_string(&grpc_path)?;
	let new_data = original_data.replace("::grpc::Client", "::modified_grpc::Client");
	
	write_to_file(&grpc_path, &new_data)?;
	Ok(())
}*/

/// Adds the file to IPFS so that 1) we can get it's hash and 2) So that we can generate a schema url from that hash
/// In parent program, lib.rs loads in the schema_url at compile time so that the library can use it.
pub fn add_file_and_write_ipfs_hash(path: &PathBuf) -> Result<(), Error> {
	use hyper::rt::Future;
	use std::sync::{Arc, Mutex};
	let client = ipfs_api::IpfsClient::default();
	
	println!("Adding {:?} to ipfs...", path);
	let should_panic = Arc::new(Mutex::new(false));
	let should_panic_clone = should_panic.clone();
	let file = File::open(path)?;
	let base_name: String = path.file_stem().unwrap().to_str().unwrap().to_string(); // Create string so that we can add it to thread.
	let req = client.add(file)
					.map(move |result| { 
						let schema_url = result.hash;
						let schema_url_file_location = format!("./schema_urls/{}.txt", base_name);
                        write_to_file(&PathBuf::from(schema_url_file_location), &schema_url).unwrap();
                    })
					.map_err(move |_e| {
						let mut data = should_panic_clone.lock().unwrap();
						*data = true; 
					});

	hyper::rt::run(req);

	// We have to panic in the main thread.
	if *should_panic.lock().unwrap() == true {
		panic!(r#"Unable to retrieve schema URL from ipfs. Make sure that IPFS daemon is running! You can get IPFS from ipfs.io\nIf you REALLY don't want to use ipfs, and care to handle the schema_url manually, modify your build.rs file."#);
	}

    Ok(())
}

pub fn for_all_in_dir(path_str: &str, func: fn(&PathBuf) -> Result<(),Error>) {
	use std::fs;
    let paths = fs::read_dir(path_str).unwrap();

    for path in paths {
		let path = path.unwrap().path();
		if let Err(e) = func(&path) {
			println!("{:?}", e);
		}
    }
}

fn write_to_file(new_file: &PathBuf, contents: &str) -> Result<(), Error> {
	use std::io::Write;

	println!("Writing file: {:?}", new_file);
	let mut file = File::create(new_file)?;
	file.write_all(contents.as_bytes())?;
	Ok(())
}
