// This file is generated by rust-protobuf 2.2.4. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Schema {
    // message oneof groups
    pub data: ::std::option::Option<Schema_oneof_data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum Schema_oneof_data {
    URL(::std::string::String),
    Ipfs(::std::string::String),
    Ipns(::std::string::String),
}

impl Schema {
    pub fn new() -> Schema {
        ::std::default::Default::default()
    }

    // string URL = 2;

    pub fn clear_URL(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_URL(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Schema_oneof_data::URL(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_URL(&mut self, v: ::std::string::String) {
        self.data = ::std::option::Option::Some(Schema_oneof_data::URL(v))
    }

    // Mutable pointer to the field.
    pub fn mut_URL(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Schema_oneof_data::URL(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Schema_oneof_data::URL(::std::string::String::new()));
        }
        match self.data {
            ::std::option::Option::Some(Schema_oneof_data::URL(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_URL(&mut self) -> ::std::string::String {
        if self.has_URL() {
            match self.data.take() {
                ::std::option::Option::Some(Schema_oneof_data::URL(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_URL(&self) -> &str {
        match self.data {
            ::std::option::Option::Some(Schema_oneof_data::URL(ref v)) => v,
            _ => "",
        }
    }

    // string Ipfs = 3;

    pub fn clear_Ipfs(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_Ipfs(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Schema_oneof_data::Ipfs(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_Ipfs(&mut self, v: ::std::string::String) {
        self.data = ::std::option::Option::Some(Schema_oneof_data::Ipfs(v))
    }

    // Mutable pointer to the field.
    pub fn mut_Ipfs(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Schema_oneof_data::Ipfs(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Schema_oneof_data::Ipfs(::std::string::String::new()));
        }
        match self.data {
            ::std::option::Option::Some(Schema_oneof_data::Ipfs(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_Ipfs(&mut self) -> ::std::string::String {
        if self.has_Ipfs() {
            match self.data.take() {
                ::std::option::Option::Some(Schema_oneof_data::Ipfs(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_Ipfs(&self) -> &str {
        match self.data {
            ::std::option::Option::Some(Schema_oneof_data::Ipfs(ref v)) => v,
            _ => "",
        }
    }

    // string Ipns = 4;

    pub fn clear_Ipns(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_Ipns(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(Schema_oneof_data::Ipns(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_Ipns(&mut self, v: ::std::string::String) {
        self.data = ::std::option::Option::Some(Schema_oneof_data::Ipns(v))
    }

    // Mutable pointer to the field.
    pub fn mut_Ipns(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Schema_oneof_data::Ipns(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(Schema_oneof_data::Ipns(::std::string::String::new()));
        }
        match self.data {
            ::std::option::Option::Some(Schema_oneof_data::Ipns(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_Ipns(&mut self) -> ::std::string::String {
        if self.has_Ipns() {
            match self.data.take() {
                ::std::option::Option::Some(Schema_oneof_data::Ipns(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_Ipns(&self) -> &str {
        match self.data {
            ::std::option::Option::Some(Schema_oneof_data::Ipns(ref v)) => v,
            _ => "",
        }
    }
}

impl ::protobuf::Message for Schema {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Schema_oneof_data::URL(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Schema_oneof_data::Ipfs(is.read_string()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.data = ::std::option::Option::Some(Schema_oneof_data::Ipns(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Schema_oneof_data::URL(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &Schema_oneof_data::Ipfs(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &Schema_oneof_data::Ipns(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &Schema_oneof_data::URL(ref v) => {
                    os.write_string(2, v)?;
                },
                &Schema_oneof_data::Ipfs(ref v) => {
                    os.write_string(3, v)?;
                },
                &Schema_oneof_data::Ipns(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Schema {
        Schema::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "URL",
                    Schema::has_URL,
                    Schema::get_URL,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "Ipfs",
                    Schema::has_Ipfs,
                    Schema::get_Ipfs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "Ipns",
                    Schema::has_Ipns,
                    Schema::get_Ipns,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Schema>(
                    "Schema",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Schema {
        static mut instance: ::protobuf::lazy::Lazy<Schema> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Schema,
        };
        unsafe {
            instance.get(Schema::new)
        }
    }
}

impl ::protobuf::Clear for Schema {
    fn clear(&mut self) {
        self.clear_URL();
        self.clear_Ipfs();
        self.clear_Ipns();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Schema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Schema {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UUID {
    // message fields
    pub id: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl UUID {
    pub fn new() -> UUID {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }
}

impl ::protobuf::Message for UUID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UUID {
        UUID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &UUID| { &m.id },
                    |m: &mut UUID| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UUID>(
                    "UUID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UUID {
        static mut instance: ::protobuf::lazy::Lazy<UUID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UUID,
        };
        unsafe {
            instance.get(UUID::new)
        }
    }
}

impl ::protobuf::Clear for UUID {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UUID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UUID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Error {
    // message fields
    pub error: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    // string error = 1;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    pub fn get_error(&self) -> &str {
        &self.error
    }
}

impl ::protobuf::Message for Error {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Error {
        Error::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &Error| { &m.error },
                    |m: &mut Error| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Error>(
                    "Error",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Error {
        static mut instance: ::protobuf::lazy::Lazy<Error> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Error,
        };
        unsafe {
            instance.get(Error::new)
        }
    }
}

impl ::protobuf::Clear for Error {
    fn clear(&mut self) {
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Data {
    // message fields
    pub schema: ::protobuf::SingularPtrField<Schema>,
    pub serialized_data: ::std::vec::Vec<u8>,
    pub sender: ::protobuf::SingularPtrField<Sender>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl Data {
    pub fn new() -> Data {
        ::std::default::Default::default()
    }

    // .Schema schema = 1;

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| Schema::default_instance())
    }

    // bytes serialized_data = 2;

    pub fn clear_serialized_data(&mut self) {
        self.serialized_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_serialized_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.serialized_data
    }

    // Take field
    pub fn take_serialized_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.serialized_data, ::std::vec::Vec::new())
    }

    pub fn get_serialized_data(&self) -> &[u8] {
        &self.serialized_data
    }

    // .Sender sender = 3;

    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: Sender) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut Sender {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> Sender {
        self.sender.take().unwrap_or_else(|| Sender::new())
    }

    pub fn get_sender(&self) -> &Sender {
        self.sender.as_ref().unwrap_or_else(|| Sender::default_instance())
    }
}

impl ::protobuf::Message for Data {
    fn is_initialized(&self) -> bool {
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.serialized_data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.serialized_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.serialized_data);
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.serialized_data.is_empty() {
            os.write_bytes(2, &self.serialized_data)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Data {
        Data::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Schema>>(
                    "schema",
                    |m: &Data| { &m.schema },
                    |m: &mut Data| { &mut m.schema },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "serialized_data",
                    |m: &Data| { &m.serialized_data },
                    |m: &mut Data| { &mut m.serialized_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sender>>(
                    "sender",
                    |m: &Data| { &m.sender },
                    |m: &mut Data| { &mut m.sender },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Data>(
                    "Data",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Data {
        static mut instance: ::protobuf::lazy::Lazy<Data> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Data,
        };
        unsafe {
            instance.get(Data::new)
        }
    }
}

impl ::protobuf::Clear for Data {
    fn clear(&mut self) {
        self.clear_schema();
        self.clear_serialized_data();
        self.clear_sender();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Data {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Data {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RpcData {
    // message fields
    pub method_name: ::std::string::String,
    pub serialized_rpc_arg: ::std::vec::Vec<u8>,
    pub schema: ::protobuf::SingularPtrField<Schema>,
    pub field_return: ::protobuf::SingularPtrField<RpcData>,
    pub sender: ::protobuf::SingularPtrField<Sender>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl RpcData {
    pub fn new() -> RpcData {
        ::std::default::Default::default()
    }

    // string method_name = 1;

    pub fn clear_method_name(&mut self) {
        self.method_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        &mut self.method_name
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.method_name, ::std::string::String::new())
    }

    pub fn get_method_name(&self) -> &str {
        &self.method_name
    }

    // bytes serialized_rpc_arg = 2;

    pub fn clear_serialized_rpc_arg(&mut self) {
        self.serialized_rpc_arg.clear();
    }

    // Param is passed by value, moved
    pub fn set_serialized_rpc_arg(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_rpc_arg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_rpc_arg(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.serialized_rpc_arg
    }

    // Take field
    pub fn take_serialized_rpc_arg(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.serialized_rpc_arg, ::std::vec::Vec::new())
    }

    pub fn get_serialized_rpc_arg(&self) -> &[u8] {
        &self.serialized_rpc_arg
    }

    // .Schema schema = 3;

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| Schema::default_instance())
    }

    // .RpcData return = 4;

    pub fn clear_field_return(&mut self) {
        self.field_return.clear();
    }

    pub fn has_field_return(&self) -> bool {
        self.field_return.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_return(&mut self, v: RpcData) {
        self.field_return = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_return(&mut self) -> &mut RpcData {
        if self.field_return.is_none() {
            self.field_return.set_default();
        }
        self.field_return.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_return(&mut self) -> RpcData {
        self.field_return.take().unwrap_or_else(|| RpcData::new())
    }

    pub fn get_field_return(&self) -> &RpcData {
        self.field_return.as_ref().unwrap_or_else(|| RpcData::default_instance())
    }

    // .Sender sender = 5;

    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: Sender) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut Sender {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> Sender {
        self.sender.take().unwrap_or_else(|| Sender::new())
    }

    pub fn get_sender(&self) -> &Sender {
        self.sender.as_ref().unwrap_or_else(|| Sender::default_instance())
    }
}

impl ::protobuf::Message for RpcData {
    fn is_initialized(&self) -> bool {
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_return {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.method_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.serialized_rpc_arg)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_return)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.method_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.method_name);
        }
        if !self.serialized_rpc_arg.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.serialized_rpc_arg);
        }
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.field_return.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.method_name.is_empty() {
            os.write_string(1, &self.method_name)?;
        }
        if !self.serialized_rpc_arg.is_empty() {
            os.write_bytes(2, &self.serialized_rpc_arg)?;
        }
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.field_return.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RpcData {
        RpcData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "method_name",
                    |m: &RpcData| { &m.method_name },
                    |m: &mut RpcData| { &mut m.method_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "serialized_rpc_arg",
                    |m: &RpcData| { &m.serialized_rpc_arg },
                    |m: &mut RpcData| { &mut m.serialized_rpc_arg },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Schema>>(
                    "schema",
                    |m: &RpcData| { &m.schema },
                    |m: &mut RpcData| { &mut m.schema },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RpcData>>(
                    "return",
                    |m: &RpcData| { &m.field_return },
                    |m: &mut RpcData| { &mut m.field_return },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sender>>(
                    "sender",
                    |m: &RpcData| { &m.sender },
                    |m: &mut RpcData| { &mut m.sender },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RpcData>(
                    "RpcData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RpcData {
        static mut instance: ::protobuf::lazy::Lazy<RpcData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RpcData,
        };
        unsafe {
            instance.get(RpcData::new)
        }
    }
}

impl ::protobuf::Clear for RpcData {
    fn clear(&mut self) {
        self.clear_method_name();
        self.clear_serialized_rpc_arg();
        self.clear_schema();
        self.clear_field_return();
        self.clear_sender();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RpcData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RpcData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ModuleInfo {
    // message fields
    pub schema: ::protobuf::SingularPtrField<Schema>,
    pub name: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl ModuleInfo {
    pub fn new() -> ModuleInfo {
        ::std::default::Default::default()
    }

    // .Schema schema = 1;

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| Schema::default_instance())
    }

    // string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }
}

impl ::protobuf::Message for ModuleInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModuleInfo {
        ModuleInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Schema>>(
                    "schema",
                    |m: &ModuleInfo| { &m.schema },
                    |m: &mut ModuleInfo| { &mut m.schema },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ModuleInfo| { &m.name },
                    |m: &mut ModuleInfo| { &mut m.name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModuleInfo>(
                    "ModuleInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModuleInfo {
        static mut instance: ::protobuf::lazy::Lazy<ModuleInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModuleInfo,
        };
        unsafe {
            instance.get(ModuleInfo::new)
        }
    }
}

impl ::protobuf::Clear for ModuleInfo {
    fn clear(&mut self) {
        self.clear_schema();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModuleInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GenerateMessageInfo {
    // message fields
    pub template: ::std::string::String,
    pub args: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub schema: ::protobuf::SingularPtrField<Schema>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl GenerateMessageInfo {
    pub fn new() -> GenerateMessageInfo {
        ::std::default::Default::default()
    }

    // string template = 1;

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: ::std::string::String) {
        self.template = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut ::std::string::String {
        &mut self.template
    }

    // Take field
    pub fn take_template(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.template, ::std::string::String::new())
    }

    pub fn get_template(&self) -> &str {
        &self.template
    }

    // repeated bytes args = 2;

    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    pub fn get_args(&self) -> &[::std::vec::Vec<u8>] {
        &self.args
    }

    // .Schema schema = 3;

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| Schema::default_instance())
    }
}

impl ::protobuf::Message for GenerateMessageInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.template)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.args)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.template.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.template);
        }
        for value in &self.args {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.template.is_empty() {
            os.write_string(1, &self.template)?;
        }
        for v in &self.args {
            os.write_bytes(2, &v)?;
        };
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenerateMessageInfo {
        GenerateMessageInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "template",
                    |m: &GenerateMessageInfo| { &m.template },
                    |m: &mut GenerateMessageInfo| { &mut m.template },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "args",
                    |m: &GenerateMessageInfo| { &m.args },
                    |m: &mut GenerateMessageInfo| { &mut m.args },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Schema>>(
                    "schema",
                    |m: &GenerateMessageInfo| { &m.schema },
                    |m: &mut GenerateMessageInfo| { &mut m.schema },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GenerateMessageInfo>(
                    "GenerateMessageInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GenerateMessageInfo {
        static mut instance: ::protobuf::lazy::Lazy<GenerateMessageInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GenerateMessageInfo,
        };
        unsafe {
            instance.get(GenerateMessageInfo::new)
        }
    }
}

impl ::protobuf::Clear for GenerateMessageInfo {
    fn clear(&mut self) {
        self.clear_template();
        self.clear_args();
        self.clear_schema();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenerateMessageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenerateMessageInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Sender {
    // message fields
    pub ipns_layer: ::std::string::String,
    pub ipns_sender: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl Sender {
    pub fn new() -> Sender {
        ::std::default::Default::default()
    }

    // string ipns_layer = 1;

    pub fn clear_ipns_layer(&mut self) {
        self.ipns_layer.clear();
    }

    // Param is passed by value, moved
    pub fn set_ipns_layer(&mut self, v: ::std::string::String) {
        self.ipns_layer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipns_layer(&mut self) -> &mut ::std::string::String {
        &mut self.ipns_layer
    }

    // Take field
    pub fn take_ipns_layer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ipns_layer, ::std::string::String::new())
    }

    pub fn get_ipns_layer(&self) -> &str {
        &self.ipns_layer
    }

    // string ipns_sender = 2;

    pub fn clear_ipns_sender(&mut self) {
        self.ipns_sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_ipns_sender(&mut self, v: ::std::string::String) {
        self.ipns_sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipns_sender(&mut self) -> &mut ::std::string::String {
        &mut self.ipns_sender
    }

    // Take field
    pub fn take_ipns_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ipns_sender, ::std::string::String::new())
    }

    pub fn get_ipns_sender(&self) -> &str {
        &self.ipns_sender
    }
}

impl ::protobuf::Message for Sender {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ipns_layer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ipns_sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ipns_layer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ipns_layer);
        }
        if !self.ipns_sender.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ipns_sender);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.ipns_layer.is_empty() {
            os.write_string(1, &self.ipns_layer)?;
        }
        if !self.ipns_sender.is_empty() {
            os.write_string(2, &self.ipns_sender)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Sender {
        Sender::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ipns_layer",
                    |m: &Sender| { &m.ipns_layer },
                    |m: &mut Sender| { &mut m.ipns_layer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ipns_sender",
                    |m: &Sender| { &m.ipns_sender },
                    |m: &mut Sender| { &mut m.ipns_sender },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Sender>(
                    "Sender",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Sender {
        static mut instance: ::protobuf::lazy::Lazy<Sender> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Sender,
        };
        unsafe {
            instance.get(Sender::new)
        }
    }
}

impl ::protobuf::Clear for Sender {
    fn clear(&mut self) {
        self.clear_ipns_layer();
        self.clear_ipns_sender();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Sender {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sender {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Destination {
    // message fields
    pub schema: ::protobuf::SingularPtrField<Schema>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl Destination {
    pub fn new() -> Destination {
        ::std::default::Default::default()
    }

    // .Schema schema = 1;

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: Schema) {
        self.schema = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema(&mut self) -> &mut Schema {
        if self.schema.is_none() {
            self.schema.set_default();
        }
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> Schema {
        self.schema.take().unwrap_or_else(|| Schema::new())
    }

    pub fn get_schema(&self) -> &Schema {
        self.schema.as_ref().unwrap_or_else(|| Schema::default_instance())
    }
}

impl ::protobuf::Message for Destination {
    fn is_initialized(&self) -> bool {
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schema)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.schema.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.schema.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Destination {
        Destination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Schema>>(
                    "schema",
                    |m: &Destination| { &m.schema },
                    |m: &mut Destination| { &mut m.schema },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Destination>(
                    "Destination",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Destination {
        static mut instance: ::protobuf::lazy::Lazy<Destination> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Destination,
        };
        unsafe {
            instance.get(Destination::new)
        }
    }
}

impl ::protobuf::Clear for Destination {
    fn clear(&mut self) {
        self.clear_schema();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Destination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Destination {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VecData {
    // message fields
    pub vec: ::protobuf::RepeatedField<Data>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl VecData {
    pub fn new() -> VecData {
        ::std::default::Default::default()
    }

    // repeated .Data vec = 1;

    pub fn clear_vec(&mut self) {
        self.vec.clear();
    }

    // Param is passed by value, moved
    pub fn set_vec(&mut self, v: ::protobuf::RepeatedField<Data>) {
        self.vec = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vec(&mut self) -> &mut ::protobuf::RepeatedField<Data> {
        &mut self.vec
    }

    // Take field
    pub fn take_vec(&mut self) -> ::protobuf::RepeatedField<Data> {
        ::std::mem::replace(&mut self.vec, ::protobuf::RepeatedField::new())
    }

    pub fn get_vec(&self) -> &[Data] {
        &self.vec
    }
}

impl ::protobuf::Message for VecData {
    fn is_initialized(&self) -> bool {
        for v in &self.vec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.vec {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.vec {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VecData {
        VecData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Data>>(
                    "vec",
                    |m: &VecData| { &m.vec },
                    |m: &mut VecData| { &mut m.vec },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VecData>(
                    "VecData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VecData {
        static mut instance: ::protobuf::lazy::Lazy<VecData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VecData,
        };
        unsafe {
            instance.get(VecData::new)
        }
    }
}

impl ::protobuf::Clear for VecData {
    fn clear(&mut self) {
        self.clear_vec();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VecData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VecData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VecModuleInfo {
    // message fields
    pub vec: ::protobuf::RepeatedField<ModuleInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl VecModuleInfo {
    pub fn new() -> VecModuleInfo {
        ::std::default::Default::default()
    }

    // repeated .ModuleInfo vec = 1;

    pub fn clear_vec(&mut self) {
        self.vec.clear();
    }

    // Param is passed by value, moved
    pub fn set_vec(&mut self, v: ::protobuf::RepeatedField<ModuleInfo>) {
        self.vec = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vec(&mut self) -> &mut ::protobuf::RepeatedField<ModuleInfo> {
        &mut self.vec
    }

    // Take field
    pub fn take_vec(&mut self) -> ::protobuf::RepeatedField<ModuleInfo> {
        ::std::mem::replace(&mut self.vec, ::protobuf::RepeatedField::new())
    }

    pub fn get_vec(&self) -> &[ModuleInfo] {
        &self.vec
    }
}

impl ::protobuf::Message for VecModuleInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.vec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.vec {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.vec {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VecModuleInfo {
        VecModuleInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModuleInfo>>(
                    "vec",
                    |m: &VecModuleInfo| { &m.vec },
                    |m: &mut VecModuleInfo| { &mut m.vec },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VecModuleInfo>(
                    "VecModuleInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VecModuleInfo {
        static mut instance: ::protobuf::lazy::Lazy<VecModuleInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VecModuleInfo,
        };
        unsafe {
            instance.get(VecModuleInfo::new)
        }
    }
}

impl ::protobuf::Clear for VecModuleInfo {
    fn clear(&mut self) {
        self.clear_vec();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VecModuleInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VecModuleInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VecRpcData {
    // message fields
    pub vec: ::protobuf::RepeatedField<RpcData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl VecRpcData {
    pub fn new() -> VecRpcData {
        ::std::default::Default::default()
    }

    // repeated .RpcData vec = 1;

    pub fn clear_vec(&mut self) {
        self.vec.clear();
    }

    // Param is passed by value, moved
    pub fn set_vec(&mut self, v: ::protobuf::RepeatedField<RpcData>) {
        self.vec = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vec(&mut self) -> &mut ::protobuf::RepeatedField<RpcData> {
        &mut self.vec
    }

    // Take field
    pub fn take_vec(&mut self) -> ::protobuf::RepeatedField<RpcData> {
        ::std::mem::replace(&mut self.vec, ::protobuf::RepeatedField::new())
    }

    pub fn get_vec(&self) -> &[RpcData] {
        &self.vec
    }
}

impl ::protobuf::Message for VecRpcData {
    fn is_initialized(&self) -> bool {
        for v in &self.vec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.vec {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.vec {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VecRpcData {
        VecRpcData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RpcData>>(
                    "vec",
                    |m: &VecRpcData| { &m.vec },
                    |m: &mut VecRpcData| { &mut m.vec },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VecRpcData>(
                    "VecRpcData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VecRpcData {
        static mut instance: ::protobuf::lazy::Lazy<VecRpcData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VecRpcData,
        };
        unsafe {
            instance.get(VecRpcData::new)
        }
    }
}

impl ::protobuf::Clear for VecRpcData {
    fn clear(&mut self) {
        self.clear_vec();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VecRpcData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VecRpcData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DataType {
    // message oneof groups
    pub result: ::std::option::Option<DataType_oneof_result>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum DataType_oneof_result {
    error(Error),
    data(Data),
    vecmoduleinfo(VecModuleInfo),
    rpcdata(RpcData),
    generatemessageinfo(GenerateMessageInfo),
    destination(Destination),
    vecdata(VecData),
    vecrpcdata(VecRpcData),
}

impl DataType {
    pub fn new() -> DataType {
        ::std::default::Default::default()
    }

    // .Error error = 1;

    pub fn clear_error(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.result = ::std::option::Option::Some(DataType_oneof_result::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut Error {
        if let ::std::option::Option::Some(DataType_oneof_result::error(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DataType_oneof_result::error(Error::new()));
        }
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        if self.has_error() {
            match self.result.take() {
                ::std::option::Option::Some(DataType_oneof_result::error(v)) => v,
                _ => panic!(),
            }
        } else {
            Error::new()
        }
    }

    pub fn get_error(&self) -> &Error {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::error(ref v)) => v,
            _ => Error::default_instance(),
        }
    }

    // .Data data = 2;

    pub fn clear_data(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Data) {
        self.result = ::std::option::Option::Some(DataType_oneof_result::data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut Data {
        if let ::std::option::Option::Some(DataType_oneof_result::data(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DataType_oneof_result::data(Data::new()));
        }
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data(&mut self) -> Data {
        if self.has_data() {
            match self.result.take() {
                ::std::option::Option::Some(DataType_oneof_result::data(v)) => v,
                _ => panic!(),
            }
        } else {
            Data::new()
        }
    }

    pub fn get_data(&self) -> &Data {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::data(ref v)) => v,
            _ => Data::default_instance(),
        }
    }

    // .VecModuleInfo vecmoduleinfo = 3;

    pub fn clear_vecmoduleinfo(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_vecmoduleinfo(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::vecmoduleinfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vecmoduleinfo(&mut self, v: VecModuleInfo) {
        self.result = ::std::option::Option::Some(DataType_oneof_result::vecmoduleinfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vecmoduleinfo(&mut self) -> &mut VecModuleInfo {
        if let ::std::option::Option::Some(DataType_oneof_result::vecmoduleinfo(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DataType_oneof_result::vecmoduleinfo(VecModuleInfo::new()));
        }
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::vecmoduleinfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vecmoduleinfo(&mut self) -> VecModuleInfo {
        if self.has_vecmoduleinfo() {
            match self.result.take() {
                ::std::option::Option::Some(DataType_oneof_result::vecmoduleinfo(v)) => v,
                _ => panic!(),
            }
        } else {
            VecModuleInfo::new()
        }
    }

    pub fn get_vecmoduleinfo(&self) -> &VecModuleInfo {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::vecmoduleinfo(ref v)) => v,
            _ => VecModuleInfo::default_instance(),
        }
    }

    // .RpcData rpcdata = 4;

    pub fn clear_rpcdata(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_rpcdata(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::rpcdata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rpcdata(&mut self, v: RpcData) {
        self.result = ::std::option::Option::Some(DataType_oneof_result::rpcdata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rpcdata(&mut self) -> &mut RpcData {
        if let ::std::option::Option::Some(DataType_oneof_result::rpcdata(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DataType_oneof_result::rpcdata(RpcData::new()));
        }
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::rpcdata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rpcdata(&mut self) -> RpcData {
        if self.has_rpcdata() {
            match self.result.take() {
                ::std::option::Option::Some(DataType_oneof_result::rpcdata(v)) => v,
                _ => panic!(),
            }
        } else {
            RpcData::new()
        }
    }

    pub fn get_rpcdata(&self) -> &RpcData {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::rpcdata(ref v)) => v,
            _ => RpcData::default_instance(),
        }
    }

    // .GenerateMessageInfo generatemessageinfo = 5;

    pub fn clear_generatemessageinfo(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_generatemessageinfo(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::generatemessageinfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_generatemessageinfo(&mut self, v: GenerateMessageInfo) {
        self.result = ::std::option::Option::Some(DataType_oneof_result::generatemessageinfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_generatemessageinfo(&mut self) -> &mut GenerateMessageInfo {
        if let ::std::option::Option::Some(DataType_oneof_result::generatemessageinfo(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DataType_oneof_result::generatemessageinfo(GenerateMessageInfo::new()));
        }
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::generatemessageinfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_generatemessageinfo(&mut self) -> GenerateMessageInfo {
        if self.has_generatemessageinfo() {
            match self.result.take() {
                ::std::option::Option::Some(DataType_oneof_result::generatemessageinfo(v)) => v,
                _ => panic!(),
            }
        } else {
            GenerateMessageInfo::new()
        }
    }

    pub fn get_generatemessageinfo(&self) -> &GenerateMessageInfo {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::generatemessageinfo(ref v)) => v,
            _ => GenerateMessageInfo::default_instance(),
        }
    }

    // .Destination destination = 6;

    pub fn clear_destination(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_destination(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::destination(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: Destination) {
        self.result = ::std::option::Option::Some(DataType_oneof_result::destination(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destination(&mut self) -> &mut Destination {
        if let ::std::option::Option::Some(DataType_oneof_result::destination(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DataType_oneof_result::destination(Destination::new()));
        }
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::destination(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destination(&mut self) -> Destination {
        if self.has_destination() {
            match self.result.take() {
                ::std::option::Option::Some(DataType_oneof_result::destination(v)) => v,
                _ => panic!(),
            }
        } else {
            Destination::new()
        }
    }

    pub fn get_destination(&self) -> &Destination {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::destination(ref v)) => v,
            _ => Destination::default_instance(),
        }
    }

    // .VecData vecdata = 7;

    pub fn clear_vecdata(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_vecdata(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::vecdata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vecdata(&mut self, v: VecData) {
        self.result = ::std::option::Option::Some(DataType_oneof_result::vecdata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vecdata(&mut self) -> &mut VecData {
        if let ::std::option::Option::Some(DataType_oneof_result::vecdata(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DataType_oneof_result::vecdata(VecData::new()));
        }
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::vecdata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vecdata(&mut self) -> VecData {
        if self.has_vecdata() {
            match self.result.take() {
                ::std::option::Option::Some(DataType_oneof_result::vecdata(v)) => v,
                _ => panic!(),
            }
        } else {
            VecData::new()
        }
    }

    pub fn get_vecdata(&self) -> &VecData {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::vecdata(ref v)) => v,
            _ => VecData::default_instance(),
        }
    }

    // .VecRpcData vecrpcdata = 8;

    pub fn clear_vecrpcdata(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_vecrpcdata(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::vecrpcdata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vecrpcdata(&mut self, v: VecRpcData) {
        self.result = ::std::option::Option::Some(DataType_oneof_result::vecrpcdata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vecrpcdata(&mut self) -> &mut VecRpcData {
        if let ::std::option::Option::Some(DataType_oneof_result::vecrpcdata(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(DataType_oneof_result::vecrpcdata(VecRpcData::new()));
        }
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::vecrpcdata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vecrpcdata(&mut self) -> VecRpcData {
        if self.has_vecrpcdata() {
            match self.result.take() {
                ::std::option::Option::Some(DataType_oneof_result::vecrpcdata(v)) => v,
                _ => panic!(),
            }
        } else {
            VecRpcData::new()
        }
    }

    pub fn get_vecrpcdata(&self) -> &VecRpcData {
        match self.result {
            ::std::option::Option::Some(DataType_oneof_result::vecrpcdata(ref v)) => v,
            _ => VecRpcData::default_instance(),
        }
    }
}

impl ::protobuf::Message for DataType {
    fn is_initialized(&self) -> bool {
        if let Some(DataType_oneof_result::error(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DataType_oneof_result::data(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DataType_oneof_result::vecmoduleinfo(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DataType_oneof_result::rpcdata(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DataType_oneof_result::generatemessageinfo(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DataType_oneof_result::destination(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DataType_oneof_result::vecdata(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DataType_oneof_result::vecrpcdata(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DataType_oneof_result::error(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DataType_oneof_result::data(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DataType_oneof_result::vecmoduleinfo(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DataType_oneof_result::rpcdata(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DataType_oneof_result::generatemessageinfo(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DataType_oneof_result::destination(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DataType_oneof_result::vecdata(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(DataType_oneof_result::vecrpcdata(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DataType_oneof_result::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DataType_oneof_result::data(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DataType_oneof_result::vecmoduleinfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DataType_oneof_result::rpcdata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DataType_oneof_result::generatemessageinfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DataType_oneof_result::destination(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DataType_oneof_result::vecdata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DataType_oneof_result::vecrpcdata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &DataType_oneof_result::error(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DataType_oneof_result::data(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DataType_oneof_result::vecmoduleinfo(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DataType_oneof_result::rpcdata(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DataType_oneof_result::generatemessageinfo(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DataType_oneof_result::destination(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DataType_oneof_result::vecdata(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DataType_oneof_result::vecrpcdata(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataType {
        DataType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Error>(
                    "error",
                    DataType::has_error,
                    DataType::get_error,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Data>(
                    "data",
                    DataType::has_data,
                    DataType::get_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VecModuleInfo>(
                    "vecmoduleinfo",
                    DataType::has_vecmoduleinfo,
                    DataType::get_vecmoduleinfo,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RpcData>(
                    "rpcdata",
                    DataType::has_rpcdata,
                    DataType::get_rpcdata,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, GenerateMessageInfo>(
                    "generatemessageinfo",
                    DataType::has_generatemessageinfo,
                    DataType::get_generatemessageinfo,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Destination>(
                    "destination",
                    DataType::has_destination,
                    DataType::get_destination,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VecData>(
                    "vecdata",
                    DataType::has_vecdata,
                    DataType::get_vecdata,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, VecRpcData>(
                    "vecrpcdata",
                    DataType::has_vecrpcdata,
                    DataType::get_vecrpcdata,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataType>(
                    "DataType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DataType {
        static mut instance: ::protobuf::lazy::Lazy<DataType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataType,
        };
        unsafe {
            instance.get(DataType::new)
        }
    }
}

impl ::protobuf::Clear for DataType {
    fn clear(&mut self) {
        self.clear_error();
        self.clear_data();
        self.clear_vecmoduleinfo();
        self.clear_rpcdata();
        self.clear_generatemessageinfo();
        self.clear_destination();
        self.clear_vecdata();
        self.clear_vecrpcdata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Transport {
    // message fields
    pub destination: ::protobuf::SingularPtrField<Schema>,
    pub payload: ::protobuf::SingularPtrField<DataType>,
    pub request_type: RequestType,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl Transport {
    pub fn new() -> Transport {
        ::std::default::Default::default()
    }

    // .Schema destination = 1;

    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: Schema) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut Schema {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> Schema {
        self.destination.take().unwrap_or_else(|| Schema::new())
    }

    pub fn get_destination(&self) -> &Schema {
        self.destination.as_ref().unwrap_or_else(|| Schema::default_instance())
    }

    // .DataType payload = 2;

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: DataType) {
        self.payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut DataType {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> DataType {
        self.payload.take().unwrap_or_else(|| DataType::new())
    }

    pub fn get_payload(&self) -> &DataType {
        self.payload.as_ref().unwrap_or_else(|| DataType::default_instance())
    }

    // .RequestType request_type = 3;

    pub fn clear_request_type(&mut self) {
        self.request_type = RequestType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_request_type(&mut self, v: RequestType) {
        self.request_type = v;
    }

    pub fn get_request_type(&self) -> RequestType {
        self.request_type
    }
}

impl ::protobuf::Message for Transport {
    fn is_initialized(&self) -> bool {
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.payload {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payload)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.request_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.request_type != RequestType::NONE {
            my_size += ::protobuf::rt::enum_size(3, self.request_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.request_type != RequestType::NONE {
            os.write_enum(3, self.request_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transport {
        Transport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Schema>>(
                    "destination",
                    |m: &Transport| { &m.destination },
                    |m: &mut Transport| { &mut m.destination },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataType>>(
                    "payload",
                    |m: &Transport| { &m.payload },
                    |m: &mut Transport| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RequestType>>(
                    "request_type",
                    |m: &Transport| { &m.request_type },
                    |m: &mut Transport| { &mut m.request_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transport>(
                    "Transport",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transport {
        static mut instance: ::protobuf::lazy::Lazy<Transport> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transport,
        };
        unsafe {
            instance.get(Transport::new)
        }
    }
}

impl ::protobuf::Clear for Transport {
    fn clear(&mut self) {
        self.clear_destination();
        self.clear_payload();
        self.clear_request_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transport {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct VecTransport {
    // message fields
    pub vec: ::protobuf::RepeatedField<Transport>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl VecTransport {
    pub fn new() -> VecTransport {
        ::std::default::Default::default()
    }

    // repeated .Transport vec = 1;

    pub fn clear_vec(&mut self) {
        self.vec.clear();
    }

    // Param is passed by value, moved
    pub fn set_vec(&mut self, v: ::protobuf::RepeatedField<Transport>) {
        self.vec = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vec(&mut self) -> &mut ::protobuf::RepeatedField<Transport> {
        &mut self.vec
    }

    // Take field
    pub fn take_vec(&mut self) -> ::protobuf::RepeatedField<Transport> {
        ::std::mem::replace(&mut self.vec, ::protobuf::RepeatedField::new())
    }

    pub fn get_vec(&self) -> &[Transport] {
        &self.vec
    }
}

impl ::protobuf::Message for VecTransport {
    fn is_initialized(&self) -> bool {
        for v in &self.vec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.vec {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.vec {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VecTransport {
        VecTransport::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transport>>(
                    "vec",
                    |m: &VecTransport| { &m.vec },
                    |m: &mut VecTransport| { &mut m.vec },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VecTransport>(
                    "VecTransport",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VecTransport {
        static mut instance: ::protobuf::lazy::Lazy<VecTransport> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VecTransport,
        };
        unsafe {
            instance.get(VecTransport::new)
        }
    }
}

impl ::protobuf::Clear for VecTransport {
    fn clear(&mut self) {
        self.clear_vec();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VecTransport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VecTransport {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum RequestType {
    NONE = 0,
    GET_INFO = 1,
    GENERATE_MESSAGE = 2,
    RECEIVE_RPC_AS_CLIENT = 3,
    RECEIVE_RPC_AS_SERVER = 4,
    RECEIVE_PUBLIC_RPC = 5,
}

impl ::protobuf::ProtobufEnum for RequestType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestType> {
        match value {
            0 => ::std::option::Option::Some(RequestType::NONE),
            1 => ::std::option::Option::Some(RequestType::GET_INFO),
            2 => ::std::option::Option::Some(RequestType::GENERATE_MESSAGE),
            3 => ::std::option::Option::Some(RequestType::RECEIVE_RPC_AS_CLIENT),
            4 => ::std::option::Option::Some(RequestType::RECEIVE_RPC_AS_SERVER),
            5 => ::std::option::Option::Some(RequestType::RECEIVE_PUBLIC_RPC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RequestType] = &[
            RequestType::NONE,
            RequestType::GET_INFO,
            RequestType::GENERATE_MESSAGE,
            RequestType::RECEIVE_RPC_AS_CLIENT,
            RequestType::RECEIVE_RPC_AS_SERVER,
            RequestType::RECEIVE_PUBLIC_RPC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RequestType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RequestType {
}

impl ::std::default::Default for RequestType {
    fn default() -> Self {
        RequestType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ftransport.proto\x12\0\"K\n\x06Schema\x12\x11\n\x03URL\x18\x02\x20\
    \x01(\tH\0B\x02\x18\0\x12\x12\n\x04Ipfs\x18\x03\x20\x01(\tH\0B\x02\x18\0\
    \x12\x12\n\x04Ipns\x18\x04\x20\x01(\tH\0B\x02\x18\0B\x06\n\x04data\"\x16\
    \n\x04UUID\x12\x0e\n\x02id\x18\x01\x20\x01(\tB\x02\x18\0\"\x1a\n\x05Erro\
    r\x12\x11\n\x05error\x18\x01\x20\x01(\tB\x02\x18\0\"]\n\x04Data\x12\x1b\
    \n\x06schema\x18\x01\x20\x01(\x0b2\x07.SchemaB\x02\x18\0\x12\x1b\n\x0fse\
    rialized_data\x18\x02\x20\x01(\x0cB\x02\x18\0\x12\x1b\n\x06sender\x18\
    \x03\x20\x01(\x0b2\x07.SenderB\x02\x18\0\"\x9a\x01\n\x07RpcData\x12\x17\
    \n\x0bmethod_name\x18\x01\x20\x01(\tB\x02\x18\0\x12\x1e\n\x12serialized_\
    rpc_arg\x18\x02\x20\x01(\x0cB\x02\x18\0\x12\x1b\n\x06schema\x18\x03\x20\
    \x01(\x0b2\x07.SchemaB\x02\x18\0\x12\x1c\n\x06return\x18\x04\x20\x01(\
    \x0b2\x08.RpcDataB\x02\x18\0\x12\x1b\n\x06sender\x18\x05\x20\x01(\x0b2\
    \x07.SenderB\x02\x18\0\";\n\nModuleInfo\x12\x1b\n\x06schema\x18\x01\x20\
    \x01(\x0b2\x07.SchemaB\x02\x18\0\x12\x10\n\x04name\x18\x02\x20\x01(\tB\
    \x02\x18\0\"Z\n\x13GenerateMessageInfo\x12\x14\n\x08template\x18\x01\x20\
    \x01(\tB\x02\x18\0\x12\x10\n\x04args\x18\x02\x20\x03(\x0cB\x02\x18\0\x12\
    \x1b\n\x06schema\x18\x03\x20\x01(\x0b2\x07.SchemaB\x02\x18\0\"9\n\x06Sen\
    der\x12\x16\n\nipns_layer\x18\x01\x20\x01(\tB\x02\x18\0\x12\x17\n\x0bipn\
    s_sender\x18\x02\x20\x01(\tB\x02\x18\0\"*\n\x0bDestination\x12\x1b\n\x06\
    schema\x18\x01\x20\x01(\x0b2\x07.SchemaB\x02\x18\0\"!\n\x07VecData\x12\
    \x16\n\x03vec\x18\x01\x20\x03(\x0b2\x05.DataB\x02\x18\0\"-\n\rVecModuleI\
    nfo\x12\x1c\n\x03vec\x18\x01\x20\x03(\x0b2\x0b.ModuleInfoB\x02\x18\0\"'\
    \n\nVecRpcData\x12\x19\n\x03vec\x18\x01\x20\x03(\x0b2\x08.RpcDataB\x02\
    \x18\0\"\xc4\x02\n\x08DataType\x12\x1b\n\x05error\x18\x01\x20\x01(\x0b2\
    \x06.ErrorH\0B\x02\x18\0\x12\x19\n\x04data\x18\x02\x20\x01(\x0b2\x05.Dat\
    aH\0B\x02\x18\0\x12+\n\rvecmoduleinfo\x18\x03\x20\x01(\x0b2\x0e.VecModul\
    eInfoH\0B\x02\x18\0\x12\x1f\n\x07rpcdata\x18\x04\x20\x01(\x0b2\x08.RpcDa\
    taH\0B\x02\x18\0\x127\n\x13generatemessageinfo\x18\x05\x20\x01(\x0b2\x14\
    .GenerateMessageInfoH\0B\x02\x18\0\x12'\n\x0bdestination\x18\x06\x20\x01\
    (\x0b2\x0c.DestinationH\0B\x02\x18\0\x12\x1f\n\x07vecdata\x18\x07\x20\
    \x01(\x0b2\x08.VecDataH\0B\x02\x18\0\x12%\n\nvecrpcdata\x18\x08\x20\x01(\
    \x0b2\x0b.VecRpcDataH\0B\x02\x18\0B\x08\n\x06result\"u\n\tTransport\x12\
    \x20\n\x0bdestination\x18\x01\x20\x01(\x0b2\x07.SchemaB\x02\x18\0\x12\
    \x1e\n\x07payload\x18\x02\x20\x01(\x0b2\t.DataTypeB\x02\x18\0\x12&\n\x0c\
    request_type\x18\x03\x20\x01(\x0e2\x0c.RequestTypeB\x02\x18\0\"+\n\x0cVe\
    cTransport\x12\x1b\n\x03vec\x18\x01\x20\x03(\x0b2\n.TransportB\x02\x18\0\
    *\x8d\x01\n\x0bRequestType\x12\x08\n\x04NONE\x10\0\x12\x0c\n\x08GET_INFO\
    \x10\x01\x12\x14\n\x10GENERATE_MESSAGE\x10\x02\x12\x19\n\x15RECEIVE_RPC_\
    AS_CLIENT\x10\x03\x12\x19\n\x15RECEIVE_RPC_AS_SERVER\x10\x04\x12\x16\n\
    \x12RECEIVE_PUBLIC_RPC\x10\x05\x1a\x02\x10\0B\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
